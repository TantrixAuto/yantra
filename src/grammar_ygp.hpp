/// @file grammar_yglx.hpp
/// @brief This file contains all the lexer-related classes required for constructing the grammar's AST
/// This file contains the following major classes
/// - Node: A Node in a Rule
/// - Rule: A grammar production
/// - RuleSet: A set of Rule's

#pragma once

#include "util.hpp"
#include "error.hpp"
#include "grammar_yglx.hpp"

namespace ygp {
struct Rule;
struct RuleSet;

/// @brief represents a node in a production
struct Node : public NonCopyable {
    /// @brief whether this node refers to a ruleset or a tokenset
    enum class NodeType : uint8_t {
        /// @brief this node refers to a ruleset
        RuleRef,

        /// @brief this node refers to a tokenset
        RegexRef,
    };

    /// @brief this node type
    NodeType type = NodeType::RegexRef;

    /// @brief position of this node in grammar file
    FilePos pos;

    /// @brief name of this node
    std::string name;

    /// @brief variable name of this node
    std::string varName;

    /// @brief autogenerated variable name of this node
    std::string idxName;

    /// @brief return true if this is a ruleset reference
    inline auto isRule() const -> bool {
        return type == NodeType::RuleRef;
    }

    /// @brief return true if this is a tokenset reference
    inline auto isRegex() const -> bool {
        return type == NodeType::RegexRef;
    }

    /// @brief return string representation of this node
    /// useful for debugging
    inline auto str() const -> std::string {
        if(varName.size() > 0) {
            return std::format("{}({})", name, varName);
        }
        return std::format("{}", name);
    }
};

/// @brief this class represents a rule in the grammar
struct Rule : public NonCopyable {
    /// @brief unique id for this rule
    size_t id = 0;

    /// @brief position in grammar file where this rule is defined
    FilePos pos;

    /// @brief name of this rule
    std::string ruleName;

    /// @brief the ruleset this rule belongs to
    ygp::RuleSet* ruleSet = nullptr;

    /// @brief list of nodes in this rule
    std::vector<std::unique_ptr<Node>> nodes;

    /// @brief index of anchor node in this rule
    size_t anchor = 0;

    /// @brief this rule takes on the precedence of this token
    const yglx::RegexSet* precedence = nullptr;

    /// @brief name of this rule's ruleset
    inline auto ruleSetName() const -> const std::string&;

    /// @brief get node at index specified by @arg idx
    inline auto getNode(const size_t& idx) const -> Node& {
        assert(idx < nodes.size());
        const auto& node = nodes.at(idx);
        return *node;
    }

    /// @brief get node at index specified by @arg idx, or null if idx is out of range
    inline auto getNodeAt(const size_t& idx) const -> Node* {
        if(idx >= nodes.size()) {
            assert(idx == nodes.size());
            return nullptr;
        }
        assert(idx < nodes.size());
        const auto& node = nodes.at(idx);
        return node.get();
    }

    /// @brief add node to rule
    inline auto addNode(const FilePos& npos, const std::string& name, const ygp::Node::NodeType& type) -> Node& {
        auto pnode = std::make_unique<Node>();
        nodes.push_back(std::move(pnode));
        auto& node = *(nodes.back());
        node.type = type;
        node.pos = npos;
        node.name = name;
        node.idxName = std::format("{}{}", name, nodes.size() - 1);
        return node;
    }

    /// @brief add regex node to rule
    inline auto addRegexNode(const FilePos& npos, const std::string& name) -> Node& {
        return addNode(npos, name, Node::NodeType::RegexRef);
    }

    /// @brief return string representation of this rule
    /// useful for debugging
    auto str(const size_t& cpos, const bool& full = true) const -> std::string;

    /// @brief return string representation of this rule
    /// useful for debugging
    inline auto str(const bool& full = true) const -> std::string {
        return str(nodes.size() + 1, full);
    }
};

/// @brief represents a set of rules that reduce to the same rule name
/// e.g:
/// stmts := stmts stmt;
/// stmts := stmt;
struct RuleSet : public NonCopyable {
    /// @brief unique id for this ruleset
    size_t id = 0;

    /// @brief name of this ruleset
    std::string name;

    /// @brief all the rules in this ruleset
    std::vector<Rule*> rules;

    /// @brief whether this ruleset has an empty production
    bool hasEpsilon = false;

    /// @brief all the tokens in the FIRST-SET of this ruleset
    /// used for constructing the LALR state machine
    std::vector<yglx::RegexSet*> firsts;

    /// @brief all the tokens in the FOLLOW-SET of this ruleset
    /// used for constructing the LALR state machine
    std::vector<yglx::RegexSet*> follows;

    /// @brief true if @arg list contains @arg name
    static inline auto hasToken(const std::vector<yglx::RegexSet*>& list, const std::string& name) -> bool {
        bool found = std::ranges::any_of(list, [&](const auto& rx) -> bool {
            return rx->name == name;
        });
        return found;
    }

    /// @brief true if FIRST-SET contains @arg t
    inline auto firstIncludes(const std::string& t) const -> bool {
        return hasToken(firsts, t);
    }
};

/// @brief represents a config for a rule
/// this is used for constructing the LALR state machine
/// it stores the @ref Rule and the position of the dot in the @ref Rule
struct Config : public NonCopyable {
    /// @brief the rule wrapped by this config
    const Rule& rule;

    /// @brief the position of the dot in this config
    size_t cpos = 0;

    inline Config(const Rule& r, const size_t& p) : rule(r), cpos(p) {}

    /// @brief return the next node from the position of the dot in this config
    inline auto getNextNode() const -> Node& {
        return rule.getNode(cpos);
    }

    /// @brief return string representation of this config
    /// used for debugging and logging
    inline auto str(const bool& full = true) const -> std::string {
        return rule.str(cpos, full);
    }
};

/// @brief This class reprsents a state in the LALR state machine
struct ItemSet : public NonCopyable {
    /// @brief represents all SHIFT actions from this ItemSet
    struct Shift {
        /// @brief the next ItemSet to shift to
        ItemSet* next = nullptr;

        /// @brief epsilon transitions from this ItemSet
        std::vector<const RuleSet*> epsilons;
    };

    /// @brief represents all REDUCE actions from this config set
    struct Reduce {
        /// @brief the next config to shift when this REDUCE action is executed
        const Config* next = nullptr;

        /// @brief length of the Rule to REDUCE
        size_t len = 0;
    };

    size_t id = 0;

    /// @brief this is the list of configs for this item
    std::vector<const Config*> configs;

    /// @brief list of SHIFT actions from this ItemSet
    std::unordered_map<const yglx::RegexSet*, Shift> shifts;

    /// @brief list of REDUCE actions from this ItemSet
    std::unordered_map<const yglx::RegexSet*, Reduce> reduces;

    /// @brief list of GOTO actions from this ItemSet
    std::unordered_map<const RuleSet*, ItemSet*> gotos;

    /// @brief check if there is a GOTO action for the given RuleSet @arg rs
    inline auto hasGoto(const RuleSet* rs) const -> ItemSet* {
        if(auto it = gotos.find(rs); it != gotos.end()) {
            return it->second;
        }
        return nullptr;
    }

    /// @brief set GOTO action for the given RuleSet @arg rs
    inline void setGoto(const Node& node, const RuleSet* rs, ItemSet* is) {
        if(hasGoto(rs) != nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "GOTO_CONFLICT:{}", rs->name);
        }
        gotos[rs] = is;
    }

    /// @brief check if there is a SHIFT action for the given token @arg rx
    inline auto hasShift(const yglx::RegexSet& rx) const -> ItemSet* {
        if(auto it = shifts.find(&rx); it != shifts.end()) {
            return it->second.next;
        }
        return nullptr;
    }

    /// @brief check if there is a SHIFT action for the given token @arg rx, leading to given ItemSet @arg is
    inline auto hasShift(const yglx::RegexSet& rx, ItemSet& is) const -> ItemSet* {
        auto* is2 = hasShift(rx);
        if((is2 == nullptr) || (is2 == &is)) {
            return nullptr;
        }
        return is2;
    }

    // /// @brief move SHIFTs from another Config to here
    // /// This is used during LALR construction, to collapse similar Configs into one
    // inline void moveShifts(const yglx::RegexSet& rx, std::vector<const ygp::Config*>& nexts, const std::vector<const ygp::RuleSet*>& epsilons) {
    //     if(hasShift(rx) == nullptr) {
    //         shifts[&rx] = Shift();
    //         shifts[&rx].epsilons = epsilons;
    //     }
    //     shifts[&rx].next = std::move(nexts);
    // }

    /// @brief delete SHIFT action for the given token @arg rx
    /// This is used when resolving a SHIFT-REDUCE conflict in
    /// favour of a REDUCE
    inline void delShift(const FilePos& npos, const yglx::RegexSet& rx) {
        if(hasShift(rx) == nullptr) {
            throw GeneratorError(__LINE__, __FILE__, npos, "UNKNOWN_SHIFT:{}", rx.name);
        }
        shifts.erase(&rx);
    }

    /// @brief check if there is a REDUCE action for the given token @arg rx
    inline auto hasReduce(const yglx::RegexSet& rx) const -> const Config* {
        if(auto it = reduces.find(&rx); it != reduces.end()) {
            return it->second.next;
        }
        return nullptr;
    }

    /// @brief check if there is a REDUCE action for the given token @arg rx, leading to given Config @arg c
    inline auto hasReduce(const yglx::RegexSet& rx, const Config& c) const -> const Config* {
        const auto* c2 = hasReduce(rx);
        if((c2 == nullptr) || (c2 == &c)) {
            return nullptr;
        }
        return c2;
    }

    /// @brief add a REDUCE action for the given token @arg rx
    inline void addReduce(const yglx::RegexSet& rx, const ygp::Config& next, const size_t& len) {
        if(hasReduce(rx) == nullptr) {
            Reduce r;
            r.len = len;
            reduces[&rx] = r;
        }
        reduces[&rx].next = &next;
    }

    /// @brief delete REDUCE action for the given token @arg rx
    /// This is used when resolving a SHIFT-REDUCE conflict in
    /// favour of a SHIFT
    inline void delReduce(const Node& node, const yglx::RegexSet& rx) {
        if(hasReduce(rx) == nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "UNKNOWN_REDUCE:{}", rx.name);
        }
        reduces.erase(&rx);
    }

    /// @brief add a SHIFT action for the given token @arg rx
    /// from current Config to @arg is ItemSet
    /// along with @arg epsilons transitions
    inline void setShift(const Node& node, const yglx::RegexSet& rx, ItemSet& is, const std::vector<const ygp::RuleSet*>& epsilons) {
        if(hasShift(rx, is) != nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "SHIFT_SHIFT_CONFLICT:{}", rx.name);
        }
        if(hasReduce(rx) != nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "SHIFT_REDUCE_CONFLICT:{}", rx.name);
        }
        auto& s = shifts[&rx];
        s.next = &is;
        s.epsilons = epsilons;
    }

    /// @brief add a REDUCE action for the given token @arg rx
    /// from current Config to @arg is ItemSet
    /// along with @arg len length of the Rule to reduce
    inline void setReduce(const Node& node, const yglx::RegexSet& rx, const Config& c, const size_t& len) {
        if(hasShift(rx) != nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "REDUCE_SHIFT_CONFLICT:{}", rx.name);
        }
        if(hasReduce(rx, c) != nullptr) {
            throw GeneratorError(__LINE__, __FILE__, node.pos, "REDUCE_REDUCE_CONFLICT:{}", rx.name);
        }
        Reduce rd;
        rd.next = &c;
        rd.len = len;
        reduces[&rx] = rd;
    }

    /// @brief return string representation of this ItemSet
    /// used for debugging and logging
    inline auto str(const std::string& indent = "", const std::string& nl = "\n", const bool& full = true) const -> std::string {
        std::stringstream ss;
        ss << indent << std::format("ItemSet:{}", id);
        for(const auto& c : configs) {
            ss << nl << indent << c->str(full);
        }
        ss << nl;
        std::string sep;
        for(const auto& s : shifts) {
            ss << sep << s.first->name <<  " -> S" << s.second.next->id;
            sep = ", ";
        }
        for(const auto& s : reduces) {
            ss << sep << s.first->name <<  " -> R" << s.second.next->rule.id;
            sep = ", ";
        }
        for(const auto& s : gotos) {
            ss << sep << s.first->name <<  " -> G" << s.second->id;
            sep = ", ";
        }
        return ss.str();
    }
};

inline auto Rule::ruleSetName() const -> const std::string& {
    assert(ruleSet != nullptr);
    return ruleSet->name;
}
}
