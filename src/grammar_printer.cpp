#include "pch.hpp"
#include "grammar_printer.hpp"

void printGrammar(const yg::Grammar& grammar, const std::filesystem::path& ofilename) {
    if(ofilename.empty() == true) {
        return;
    }

    auto map = std::ofstream(ofilename);

    std::println(map, "# Notes");
    std::println(map, "- This file is best viewed in Visual Studio Code using the Mermaid Preview plugin.");
    std::println(map, "- This file was generated by Yantra (will be overwritten on every run).");
    std::println(map, "- Parser is CLR(1) at the moment.");

    std::println(map, "# Lexer State Machine");

    std::vector<size_t> endStates;
    std::println(map, "```mermaid");
    std::println(map, "stateDiagram");
    for(auto& ps : grammar.states) {
        auto& state = *ps;

        auto txs = state.transitions;
        txs.insert(txs.end(), state.superTransitions.begin(), state.superTransitions.end());
        txs.insert(txs.end(), state.shadowTransitions.begin(), state.shadowTransitions.end());

        for(auto& tx : txs) {
            std::println(map, "  {} --> {}:{}", state.id, zid(tx->next), tx->str(true));
        }

        std::string c;
        if(state.closure != nullptr) {
            c = "*";
        }
        if(state.matchedRegex) {
            std::println(map, "state \"{}{}<br/>({})\" as {}", state.id, c, state.matchedRegex->regexName, state.id);
            endStates.push_back(state.id);
        }else{
            std::println(map, "state \"{}{}\" as {}", state.id, c, state.id);
        }

        if(state.checkEOF) {
            std::println(map, "state \"{} -> END\" as {}", state.id, state.id);
        }
    }

    std::println(map, "classDef startState font-weight:bold,stroke-width:2px,stroke:blue;");
    std::println(map, "  class {} startState", 1);
    std::println(map, "classDef endState font-weight:bold,stroke-width:2px,stroke:green;");
    for(auto& s : endStates) {
        std::println(map, "  class {} endState", s);
    }
    std::println(map, "```");

    std::println(map, "# LALR(1) State Machine");
    std::println(map, "```mermaid");
    std::println(map, "%%{{init: {{ 'maxTextSize': 999999999 }}}}%%");
    std::println(map, "stateDiagram");
    if(grammar.itemSets.size() < 32) {
        for(auto& ps : grammar.itemSets) {
            auto& itemSet = *ps;
            std::println(map, "state \"== State:{} ==", itemSet.id);
            for(auto& c : itemSet.configs) {
                std::println(map, "{}<br/>", c->str());
            }
            std::println(map, "\" as S{}", itemSet.id);
        }
    }

    endStates.clear();
    for(auto& ps : grammar.itemSets) {
        auto& itemSet = *ps;
        for(auto& t : itemSet.shifts) {
            std::println(map, "S{} --> S{}: SHIFT ON [{}]", itemSet.id, t.second.next->id, t.first->name);
        }

        for(auto& t : itemSet.reduces) {
            std::println(map, "S{} --> R{}: REDUCE ON [{}]", itemSet.id, t.second.next->rule.ruleName, t.first->name);
        }

        for(auto& t : itemSet.gotos) {
            std::println(map, "S{} --> S{}: GOTO ON [{}]", itemSet.id, t.second->id, t.first->name);
        }

        if(itemSet.reduces.size() > 0) {
            endStates.push_back(itemSet.id);
        }
    }

    std::println(map, "classDef startState font-weight:bold,stroke-width:2px,stroke:blue;");
    std::println(map, "  class S{} startState", 1);
    std::println(map, "classDef endState font-weight:bold,stroke-width:2px,stroke:green;");
    for(auto& s : endStates) {
        std::println(map, "  class S{} endState", s);
    }
    std::println(map, "```");
}
