%class Calculator;

// Region:Rules

start := numexpr;

numexpr := addorsubexpr;

addorsubexpr := addorsubexpr PLUS mulordivexpr
%{
    startExpression("Adding:");
%}

addorsubexpr := addorsubexpr MINUS mulordivexpr
%{
    startExpression("Subtracting:");
%}

addorsubexpr := mulordivexpr;

mulordivexpr := mulordivexpr MUL valexpr
%{
    startExpression("Multiplying:");
%}

mulordivexpr := mulordivexpr DIV valexpr
%{
    startExpression("Dividing:");
%}

mulordivexpr := valexpr;

valexpr := LPAREN numexpr RPAREN;

valexpr := NUMBER (NUM)
%{
    appendNumber(NUM.text);
%}

// Region:Tokens

%left PLUS MINUS;
%left MUL DIV;

NUMBER := "\d+";
PLUS   := "\+";
MINUS  := "-";
MUL    := "\*";
DIV    := "/";
LPAREN := "\(";
RPAREN := "\)";
WS     := "\s+"!;

// Region:Walkers

%walkers ShowTree;
%default_walker ShowTree;

%members ShowTree
%{
    int level = 0; // Current level of indentation
    int inExpression = 0; // Position of current NUMBER
    
    // Return as many spaces as value of `level`,
    // for indenting.
    std::string indentLevel() {
        std::string result(level,' ');
        return result;
    }
    
    // Start a new level, when a new expression 
    // starts.
    void startExpression(std::string exprName) {
        std::cout << indentLevel() << exprName << std::endl;
    
        level++;
        inExpression = 0;
    }
    
    // When a number is output, increase 
    // `inExpression`. If it is even (because our
    // expressions take two numbers), decrease 
    // the level because the expression is done.
    void appendNumber(std::string numText) {
        std::cout << indentLevel() << "Number: " << numText << std::endl; 
    
        inExpression++;
        if(inExpression % 2 == 0) {
            level--;
            inExpression--;
        }
    }
%}
